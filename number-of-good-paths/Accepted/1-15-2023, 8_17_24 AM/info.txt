{"id":878343666,"lang":"java","lang_name":"Java","time":"3Â months, 3Â weeks","timestamp":1673750844,"status":10,"status_display":"Accepted","runtime":"30 ms","url":"/submissions/detail/878343666/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"63.2 MB","code":"class Solution {\n    int[] parents, count, vals;\n    int res;\n    public int numberOfGoodPaths(int[] vals, int[][] edges) {\n        this.vals=vals;\n        // Unlike other strategies where we focus on the nodes to select the order of the\n        // merging of groups, here we will focus on the edges (paths). Each edge always adds\n        // two groups, and sorting them in this order ensures that we will always be merging\n        // groups with maximum values from min to max. I.e every group has a max value, so we\n        // merge the ones whith smaller to max.\n        Arrays.sort(edges, (a,b)->Math.max(vals[a[0]], vals[a[1]])-Math.max(vals[b[0]],vals[b[1]]));\n        // Minimum number of good paths is equal to the number of nodes\n        res = vals.length;\n        // Parent array\n        parents = new int[vals.length];\n        for(int i = 0; i < vals.length; i++) parents[i] = i;\n        // Count array to keep track of number of child nodes with value equal to the parent\n        // Note: Also the way we will implement will ensure that the parent is always the\n        // biggest value.\n        count = new int[vals.length];\n        // Processing each edge and connecting adjacent nodes into one component. Please\n        // understand first the comment about the sorting.\n        for(int[] edge: edges) union(edge[0], edge[1]);\n        return res;\n    }\n    \n    // Important: usually here you see the union by rank, but in this case the union is to\n    // the parent with biggest value. If they have the same value any of them surfices.\n    boolean union(int a, int b) {\n        int pa = parent(a);\n        int pb = parent(b);\n        if(pa == pb) return false;\n        //If two adjacent node have same value, they will increase the number of good paths\n        // corresponding to the number of nodes in their component\n        // We will choose pa as parent, but it could have been pb\n        if(vals[pa] == vals[pb]) {\n            // the +1 is because every group also has the parent with the max value\n            res += (count[pa]+1)*(count[pb]+1);\n            count[pa] += count[pb]+1;\n            parents[pb] = pa;\n        } \n        // If two nodes have different values, join the smaller one to the larger one\n        else if(vals[pa] > vals[pb]) parents[pb] = pa;\n        else parents[pa] = pb;\n        return true;\n    }\n    \n    private int parent(int a) {\n        int p;\n        if((p=parents[a])!=a) p=parents[a]=parent(p);\n        return p;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-good-paths","has_notes":false}