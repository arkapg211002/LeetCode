{"id":913096460,"lang":"java","lang_name":"Java","time":"1 month, 3 weeks","timestamp":1678520376,"status":10,"status_display":"Accepted","runtime":"76 ms","url":"/submissions/detail/913096460/","is_pending":"Not Pending","title":"Merge BSTs to Create Single BST","memory":"65.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int prev = Integer.MIN_VALUE;\n    public boolean isValid(TreeNode root){\n        if(root != null){\n            if(!isValid(root.left)) return false;\n            if(root.val<=prev) return false;\n            prev=root.val;\n            return isValid(root.right);\n        }\n        return true;\n    }\n    public TreeNode canMerge(List<TreeNode> trees) {\n        Map<Integer, TreeNode> map = new HashMap<>();\n        for(TreeNode node:trees)\n            map.put(node.val, node);\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can't use that\n        for(TreeNode node:trees){\n            if(!merged.contains(node.val)){\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \n                set.add(node.val);\n                Queue<TreeNode> queue = new LinkedList<>();\n                queue.add(node);\n                while(!queue.isEmpty()){\n                    TreeNode n = queue.remove();\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\n                        n.left = map.get(n.left.val);\n                        set.add(n.left.val);\n                        merged.add(n.left.val);\n                        queue.add(n.left);\n                    }\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\n                        n.right=map.get(n.right.val);\n                        set.add(n.right.val);\n                        merged.add(n.right.val);\n                        queue.add(n.right);\n                    }\n                }\n            }\n        }\n        int cnt=0;\n        TreeNode ans=null;\n        for(TreeNode node:trees){\n            if(!merged.contains(node.val)){\n                cnt++;\n                ans=node;\n            }\n            if(cnt>1) return null;\n        }\n        System.out.println(cnt);\n        if(isValid(ans)) return ans;\n        System.out.println(\"Invalid\");\n        return null;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-bsts-to-create-single-bst","has_notes":false}