{"id":912250093,"lang":"java","lang_name":"Java","time":"1 month, 4 weeks","timestamp":1678386408,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/912250093/","is_pending":"Not Pending","title":"Path Sum III","memory":"41.9 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    int target;\n    HashMap<Long, Long> prefixSumToFreq = new HashMap<>();\n    int num;\n\n    /*\n    \n    IDEA:\n    Consider a prefix sum array -> prefixSum[i] = sum of all elements in the array in the indexes [0, i]\n    Thus prefixSum[i] = sum of elements in [0, i] = sum of elements in [0, j] + sum of elements in [j + 1, i] where j < i\n\n    To find if there is a subarray which ends at index i and has sum = target we need sum of elements in [j + 1, i] = target\n    i.e we need sum of elements in [0, j] = prefixSum[i] - target\n\n    We can persist this information in a hashmap which stores prefixSum and frequency it is observed\n    So we don't need an explicit array! - just track the prefixSum\n\n    The only caveat is since this is a tree problem you need to reduce frequency of prefixSum after you have explored the subtree\n    \n     */\n\n    public int pathSum(TreeNode root, int targetSum) {\n        target = targetSum;\n\n        // when map is empty sum of all elements is 0 so we have observed prefix sum = 0 1 times\n        prefixSumToFreq.put(0l, 1l);\n\n        traverse(root, 0);\n        return num;\n    }\n\n    private void traverse(TreeNode node, long prefixSum) {\n        \n        if(node == null)\n            return;\n\n        // add current value to prefixSum (i.e we 'include' it in the subarray)\n        prefixSum += node.val;\n\n        // find number of subarrays with prefix sum = prefixSum - target - these are the number of paths which sum to target\n        num += prefixSumToFreq.getOrDefault(prefixSum - target, 0l);\n        \n        // since we observed a subarray with sum = prefixSum increase its frequency by 1\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.getOrDefault(prefixSum, 0l) + 1);\n\n        traverse(node.left, prefixSum);\n        traverse(node.right, prefixSum);\n\n        // reduce frequency of prefixSum by 1\n        // remove it from the map if reduced frequency equals 0\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.get(prefixSum) - 1);\n        if(prefixSumToFreq.get(prefixSum) == 0)\n            prefixSumToFreq.remove(prefixSum);\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-iii","has_notes":false}