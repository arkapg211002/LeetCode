{"id":934586555,"lang":"java","lang_name":"Java","time":"3 weeks, 1 day","timestamp":1681629280,"status":10,"status_display":"Accepted","runtime":"374 ms","url":"/submissions/detail/934586555/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"132.3 MB","code":"class Solution {\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        List<Set<Integer>> adj = new ArrayList<>();\n        int[] parent = new int[n];\n        for(int i=0;i<n;i++){\n            adj.add(new HashSet<>()); // We use hashset so that removal of edge is quick\n            parent[i] = -1;\n        }\n        for(List<Integer> edge: connections) {\n            adj.get(edge.get(0)).add(edge.get(1));\n            adj.get(edge.get(1)).add(edge.get(0));\n        }\n        \n        Stack<Integer> stack = new Stack<>();\n        boolean[] visited = new boolean[n];\n        for(int i=0;i<n;i++) {\n            if(!visited[i]){\n                getOrder(adj, stack, parent, visited, i); // Fill stack for ordering\n            }\n        }\n        \n        for(int i=0;i<n;i++){\n            if(parent[i]!=-1){\n                adj.get(parent[i]).remove(i); // This is similar to the case where we have to build the transpose graph as per Kosaraju's Algo\n            }\n        }\n        Arrays.fill(visited, false);\n        \n        List<List<Integer>> criticals = new ArrayList<>();\n        while(!stack.isEmpty()) {\n            int v = stack.pop();\n            if(!visited[v]){\n                if(parent[v]!=-1){\n                    criticals.add(Arrays.asList(parent[v], v)); // Whenever we pop from stack and the component is unvisited it means a new SCC \n                }\n                dfs(adj, visited, v);\n            }\n        }\n        \n        return criticals;\n    }\n    \n    private void getOrder(List<Set<Integer>> adj, Stack<Integer> stack, int[] parent, boolean[] visited, int s) {\n        visited[s] = true;\n        \n        for(int n: adj.get(s)) {\n            if(!visited[n]){\n                parent[n] = s;\n                getOrder(adj, stack, parent, visited, n);\n            }\n        }\n        \n        stack.push(s);\n    }\n    \n    private void dfs(List<Set<Integer>> adj, boolean[] visited, int s) {\n        visited[s] = true;\n        \n        for(int n: adj.get(s)) {\n            if(!visited[n]){\n                dfs(adj, visited, n);\n            }\n        }\n        \n    }\n}","compare_result":"11111111111111111","title_slug":"critical-connections-in-a-network","has_notes":false}