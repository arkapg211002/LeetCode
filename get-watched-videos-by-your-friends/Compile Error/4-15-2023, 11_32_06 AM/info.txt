{"id":933967377,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1681538526,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/933967377/","is_pending":"Not Pending","title":"Get Watched Videos by Your Friends","memory":"N/A","code":"class Solution {\npublic:\n    queue<int> q;\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \n    {\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\n        vector<pair<int,string>> resultPairs;\n        vector<string> result;\n        q.push(id);                  //Push initial node/friend id.\n        visited[id]=true;            \n        while(!q.empty()&&level--)\t{\t\t\t//BFS to get to the level.\n            for(int i=q.size();i;q.pop(),i--) {\n                for(int &i:friends[q.front()])\n                    if(!visited[i]) {\n                        visited[i]=true;\n                        q.push(i);\n                    }\n            }\n        }\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\n            for(string &s:watchedVideos[q.front()])\n                count[s]++;\n            q.pop();\n        }\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\n            resultPairs.push_back({it->second,it->first});\n        sort(resultPairs.begin(),resultPairs.end());\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\n        return result;            \n    }\n};","compare_result":null,"title_slug":"get-watched-videos-by-your-friends","has_notes":false}