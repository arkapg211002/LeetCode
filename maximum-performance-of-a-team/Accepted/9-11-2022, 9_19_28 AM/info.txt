{"id":796800950,"lang":"java","lang_name":"Java","time":"7 months, 4 weeks","timestamp":1662868168,"status":10,"status_display":"Accepted","runtime":"89 ms","url":"/submissions/detail/796800950/","is_pending":"Not Pending","title":"Maximum Performance of a Team","memory":"69.1 MB","code":"class Solution {\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n        int[][] players = new int[n][2];\n        for (int i=0; i<n; i++) {\n            players[i][0] = efficiency[i];\n            players[i][1] = speed[i];\n        }\n\t\t// Sort the players based on efficiency in decreasing order, as for each iteration, we'll consider only players with higher efficiency.\n        Arrays.sort(players, (p1, p2) -> (p2[0] - p1[0]));\n\n\t\t// Priority-Queue to maintain players with highest relative speeds with efficiencies greater than the one under iteration.\n        PriorityQueue<Integer> speedQueue = new PriorityQueue<>(k);\n        long teamPerformance = 0, teamSpeed = 0;\n\n        for (int i=0; i<n; i++) {\n\t\t\t// This is because a team can have atmost `k` players.\n            if (speedQueue.size() >= k) {\n                teamSpeed -= speedQueue.remove();\n            }\n            speedQueue.add(players[i][1]);\n            teamSpeed += players[i][1];\n\n            teamPerformance = Math.max(teamPerformance, teamSpeed * players[i][0]);\n        }\n        return (int) (teamPerformance % 1000000007);\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"maximum-performance-of-a-team","has_notes":false}