{"id":934584662,"lang":"java","lang_name":"Java","time":"3 weeks, 1 day","timestamp":1681628993,"status":10,"status_display":"Accepted","runtime":"154 ms","url":"/submissions/detail/934584662/","is_pending":"Not Pending","title":"Number Of Ways To Reconstruct A Tree","memory":"99.6 MB","code":"class Solution {\n    public int checkWays(int[][] pairs) {\n        int result = 1;\n        \n        //Create adjacency list\n        Map<Integer, Set<Integer>> edges = new HashMap<>();\n        for (int[] pair: pairs) {\n            edges.computeIfAbsent(pair[0], x->new HashSet<>()).add(pair[0]);\n            edges.computeIfAbsent(pair[1], x->new HashSet<>()).add(pair[1]);\n            edges.get(pair[0]).add(pair[1]);\n            edges.get(pair[1]).add(pair[0]);\n        }\n        \n        //Sort the edge lists based on their size\n        List<Map.Entry<Integer, Set<Integer>>> edgesList = new ArrayList(edges.entrySet());\n        Collections.sort(edgesList, (a,b)-> b.getValue().size() - a.getValue().size());\n        \n        List<Map.Entry<Integer, Set<Integer>>> previous = new ArrayList<>();\n        \n\t\t// Now from each of the edges find the ways to create the tree\n\t\tfor (Map.Entry<Integer, Set<Integer>> cur: edgesList) {\n            //get the current edge set\n\t\t\tSet<Integer> currentSet = cur.getValue();\n            //find the parent for the current set from the previously computed edge\n\t\t\tMap.Entry<Integer, Set<Integer>> parent = find(previous, currentSet);\n            // if the parent is null\n\t\t\tif (parent==null) {\n                // if you the current set do not match with the edges size then there is no way, return 0\n\t\t\t\tif (currentSet.size() != edges.size())\n                    return 0;\n            } else {\n                Set<Integer> parentSet = parent.getValue();\n                // if the current set do not contain everything from the parent then also return 0\n\t\t\t\tif (!parentSet.containsAll(currentSet)) return 0;\n                // if the parent contains everything from the current set then return more than one ways\n\t\t\t\tif (parentSet.equals(currentSet)) result = 2;\n            }\n            // add the computed edge to previous list\n            previous.add(cur);\n        }\n\t\t\n\t\t// only one way\n        return result;\n    }\n\t\n\tMap.Entry<Integer, Set<Integer>> find(List<Map.Entry<Integer, Set<Integer>>> previous, Set<Integer> currentSet) {\n        int i=previous.size()-1;\n        while (i>=0) {\n            Map.Entry<Integer, Set<Integer>> entry = previous.get(i--);\n            if (currentSet.contains(entry.getKey())) return entry;\n        }\n        return null;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-ways-to-reconstruct-a-tree","has_notes":false}