{"id":929166214,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1680801814,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/929166214/","is_pending":"Not Pending","title":"Number of Closed Islands","memory":"43.2 MB","code":"class Solution {\n    \n    public int closedIsland(int[][] grid) {\n\n        /*\n         * Base Condition :\n         * If row or column length is less than 3 all the values will be somehow connected to perimeter.\n         * So there can't be a island.\n         */\n        if (grid.length < 3 || grid[0].length < 3) {\n            return 0;\n        }\n\n        int numberOfClosedIsland = 0;\n\n        /*\n         * In the perimeter of the grid, irrespective of land(0) or water(0) it will never be a closed island.\n         * So, we want to confined our search from (row - 1) to (grid.length - 2) i.e. Skipping first row and last row.\n         * Same thing is applicable to columns also for column also we want to confined our search from\n         * (col - 1) to (grid[0].length - 2) i.e. Skipping first col and last col.\n         */\n        for (int i = 1; i < grid.length - 1; i++) {\n            for (int j = 1; j < grid[0].length - 1; j++) {\n                // Try to explore if is a land\n                if (grid[i][j] == 0) {\n                    if (exploreIsland(i, j, grid)) {\n                        numberOfClosedIsland++;\n                    }\n                }\n            }\n        }\n\n        return numberOfClosedIsland;\n    }\n\n    /*\n     * Will try to explore the part with DFS\n     * 0 : Land  ,   1 : Water     &   -1 : Visited Position\n     */\n    public boolean exploreIsland(int row, int col, int[][] grid) {\n\n\n        /*\n         *   *****  NOTE : Keep this condition before base condition of perimeter. Other wise this method will always return false.\n         *\n         * If we are reaching till to a position which is water or already explored we can return true.\n         * As this can lead to a probable closed island\n         */\n        if (grid[row][col] == 1 || grid[row][col] == -1) {\n            return true;\n        }\n\n        /*\n         * Base Condition :\n         * Irrespective of land(0) or water(0) if any of the position is lying on the perimeter we want to return false.\n         * Because if it is lying on the perimeter it will never be a closed island.\n         *\n         * So, we want to confined our search from (row - 1) to (grid.length - 2) i.e. Skipping first row and last row.\n         * For column also we want to confined our search from (col - 1) to (grid[0].length - 2) i.e. Skipping first col and last col.\n         *\n         * So if current row is reaching to position 0 or (grid.length - 1) we can return false.\n         * For column also if it is reaching to position 0 or (grid[0].length - 1) we can return false.\n         */\n        if (row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1) {\n            return false;\n        }\n\n\n        // To denote that this position is visited, instead of boolean[] visited array.\n        grid[row][col] = -1;\n\n        //Explore left side\n        boolean left = exploreIsland(row, col - 1, grid);\n        //Explore right side\n        boolean right = exploreIsland(row, col + 1, grid);\n        //Explore Up side\n        boolean up = exploreIsland(row - 1, col, grid);\n        //Explore down side\n        boolean down = exploreIsland(row + 1, col, grid);\n\n        // It will be only closed island if all the side has water in it. So, final result will be ( left && right && up && down )\n        return left && right && up && down;\n    }\n    \n}","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"number-of-closed-islands","has_notes":false}