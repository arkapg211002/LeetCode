{"id":941925428,"lang":"java","lang_name":"Java","time":"1 week, 1 day","timestamp":1682828310,"status":10,"status_display":"Accepted","runtime":"13 ms","url":"/submissions/detail/941925428/","is_pending":"Not Pending","title":"Remove Max Number of Edges to Keep Graph Fully Traversable","memory":"119.9 MB","code":"class Solution {\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\n    if (edges.length < n - 1) return -1; \n    int[] parentAlice = new int[n + 1];\n    for (int i = 0; i < parentAlice.length; i++) parentAlice[i] = i;\n    int numType3Edges = 0;\n    for (int[] edge : edges) \n    {\n      if (edge[0] == 3) \n      {\n        if (union(parentAlice, edge[1], edge[2])) \n          numType3Edges++;\n      }\n    }\n    int[] parentBob = parentAlice.clone(); \n    int numType1Edges = 0;\n    for (int[] edge : edges) \n    {\n      if (edge[0] == 1)\n      {\n        if (union(parentAlice, edge[1], edge[2])) \n          numType1Edges++;\n      }\n    }\n    if (numType1Edges + numType3Edges + 1 != n) return -1; \n    int numType2Edges = 0;\n    for (int[] edge : edges) \n    {\n      if (edge[0] == 2) \n      {\n        if (union(parentBob, edge[1], edge[2])) \n          numType2Edges++;\n        \n      }\n    }\n    if (numType2Edges + numType3Edges + 1 != n) return -1;\n    return edges.length - numType1Edges - numType2Edges - numType3Edges;\n  }\n  int find(int[] parent, int node) \n  {\n    if (parent[node] != node) \n    {\n      parent[node] = find(parent, parent[node]);\n    }\n    return parent[node];\n  }\n\n  boolean union(int[] parent, int left, int right) \n  {\n    int leftParent = find(parent, left);\n    int rightParent = find(parent, right);\n    if (leftParent == rightParent) return false;\n    parent[rightParent] = leftParent;\n    return true;\n  }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-max-number-of-edges-to-keep-graph-fully-traversable","has_notes":false}