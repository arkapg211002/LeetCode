{"id":800923116,"lang":"java","lang_name":"Java","time":"7 months, 3 weeks","timestamp":1663294738,"status":10,"status_display":"Accepted","runtime":"45 ms","url":"/submissions/detail/800923116/","is_pending":"Not Pending","title":"Maximum Score from Performing Multiplication Operations","memory":"72.9 MB","code":"class Solution {\n  public int maximumScore(int[] nums, int[] multipliers) {\n\n    int N = nums.length;\n    int M = multipliers.length;\n\n    // Pointer for traversing the multipliers array.\n    int current = M;\n\n    // Memoization involves saving the optimum solution from the previous operation for easy retrieval.\n    // This is so that we can avoid repeating the operation, thus lowering time complexity.\n    int[] maximumScore = new int[M];\n    int[] memo = new int[M+1];\n\n    // As we traverse from back to front of the multipliers array, \n    // we are also multiplying from the ends (left and right) to the center of the nums array.\n    // Each iteration, we get the higher value sums of the multiplication and highest value from previous round (memo).\n    // Note:\n    // Imagine the first multiple (0) in the multipliers can only choose first left or right in the nums.\n    // While the last multiple (M-1) in the multipliers can possibly choose 0 to M-th number from left or right nums.\n    while (--current >= 0) {\n        for (int i = 0; i <= current; ++i) {\n            int left = memo[i+1] + multipliers[current] * nums[i];\n            int right = memo[i] + multipliers[current] * nums[N - current + i - 1];\n            maximumScore[i] = Math.max(left, right);\n        }\n        // Store the current round of maximumScores in the memo, for reference in the next round.\n        memo = maximumScore;\n    }\n    return maximumScore[0];\n}\n}","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"maximum-score-from-performing-multiplication-operations","has_notes":false}