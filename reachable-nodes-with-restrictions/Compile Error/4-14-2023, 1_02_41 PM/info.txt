{"id":933501694,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1681457561,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/933501694/","is_pending":"Not Pending","title":"Reachable Nodes With Restrictions","memory":"N/A","code":"private final Set<Integer> reachableSet = new HashSet<>(List.of(0));\n\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\n        Set<Integer> restrictedNodes = Arrays.stream(restricted).boxed().collect(Collectors.toSet());\n        Map<Integer, List<Integer>> nodes = new HashMap<>();\n\n        for (int[] edge : edges) {\n            nodes.computeIfAbsent(edge[0], value -> new ArrayList<>()).add(edge[1]);\n            nodes.computeIfAbsent(edge[1], value -> new ArrayList<>()).add(edge[0]);\n        }\n\n        dfs(nodes, 0, restrictedNodes, new HashSet<>());\n        return reachableSet.size();\n    }\n\n    private void dfs(Map<Integer, List<Integer>> nodes, int current, Set<Integer> restricted, Set<Integer> seen) {\n        for (int node : nodes.get(current)) {\n            if (!restricted.contains(node) && !seen.contains(node)) {\n                reachableSet.add(node);\n                seen.add(node);\n                dfs(nodes, node, restricted, seen);\n            }\n        }\n    }","compare_result":null,"title_slug":"reachable-nodes-with-restrictions","has_notes":false}