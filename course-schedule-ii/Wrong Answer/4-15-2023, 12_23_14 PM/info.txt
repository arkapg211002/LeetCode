{"id":933987313,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1681541594,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/933987313/","is_pending":"Not Pending","title":"Course Schedule II","memory":"N/A","code":"class Solution {\n    public int[] findOrder(int numCourses, int[][] pre) {\n        int n=numCourses;\n        if(pre.length==0)\n        {\n            int res[]=new int[n];\n            for(int i=0;i<n;i++)res[i]=i;\n            return res;\n        }\n        if(pre.length<n-1)\n        {\n            HashSet<Integer>hs=new HashSet<>();\n            for(int i=0;i<pre.length;i++)\n            {\n                hs.add(pre[i][0]);\n                hs.add(pre[i][1]);\n            }\n            n=hs.size();\n        }\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\n        List<Integer>d=new ArrayList<>();\n        for(int i=0;i<numCourses;i++)l.add(new ArrayList<>());\n        for(int r[]:pre)\n            l.get(r[1]).add(r[0]);\n        System.out.println(l);\n        if(isCyclic(n,l)==true)\n        {\n            return new int[0];\n        }\n        for(int i=0;i<n;i++)\n        {\n            d=new ArrayList<>();\n            int v[]=new int[n];\n            int p[]=new int[n];\n            bfs(i,l,v,d);\n            //System.out.println(d);\n            if(d.size()==n)break;\n        }\n        System.out.println(d);\n        for(int i=0;i<l.size();i++)\n        {\n            if(l.get(i).size()==0 && d.contains(i)==false)d.add(i);\n        }\n        if(d.size()!=numCourses)return new int[0];\n        else\n        {\n            int ans[]=new int[numCourses];\n            for(int i=0;i<numCourses;i++)\n                ans[i]=d.get(i);\n            return ans;\n        }\n    }\n    public void bfs(int node,ArrayList<ArrayList<Integer>>l,int v[],List<Integer>d)\n    {\n        Queue<Integer>q=new LinkedList<>();\n        q.add(node);\n        v[node]=1;\n        while(!q.isEmpty())\n        {\n            int nd=q.poll();\n            d.add(nd);\n            for(Integer it:l.get(nd))\n            {\n                if(v[it]==0)\n                {\n                    q.add(it);\n                    v[it]=1;\n                }\n            }\n        }\n    }\n    public boolean isCyclic(int V, ArrayList<ArrayList<Integer>> adj) {\n        int vis[] = new int[V];\n        int pathVis[] = new int[V];\n        \n        for(int i = 0;i<V;i++) {\n            if(vis[i] == 0) {\n                if(dfs(i, adj, vis, pathVis) == true) return true; \n            }\n        }\n        return false; \n    }\n    public boolean dfs(int node, ArrayList<ArrayList<Integer>> adj, int vis[], int pathVis[]) {\n        vis[node] = 1; \n        pathVis[node] = 1; \n        \n        // traverse for adjacent nodes \n        for(int it : adj.get(node)) {\n            // when the node is not visited \n            if(vis[it] == 0) {\n                if(dfs(it, adj, vis, pathVis) == true) \n                    return true; \n            }\n            // if the node has been previously visited\n            // but it has to be visited on the same path \n            else if(pathVis[it] == 1) {\n                return true; \n            }\n        }\n        \n        pathVis[node] = 0; \n        return false; \n    }\n}","compare_result":"111111111110110111111111100000000000000000000","title_slug":"course-schedule-ii","has_notes":false}