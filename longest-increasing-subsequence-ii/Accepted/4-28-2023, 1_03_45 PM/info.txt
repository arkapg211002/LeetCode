{"id":940988646,"lang":"java","lang_name":"Java","time":"1 week, 2 days","timestamp":1682667225,"status":10,"status_display":"Accepted","runtime":"132 ms","url":"/submissions/detail/940988646/","is_pending":"Not Pending","title":"Longest Increasing Subsequence II","memory":"60.5 MB","code":"\nclass Solution {\n    class Node{\n        int val;\n        Node left;\n        Node right;\n        int start;\n        int end;\n    }\n    public int lengthOfLIS(int[] nums, int k) {\n        int max = 0;\n        for(int num : nums){\n            max = Math.max(max,num);\n        }\n        \n        Node root = construct(1,max);\n        \n        int res = 0;\n        for(int num : nums){\n            int lo = (num - k) < 1 ? 1 : (num - k);\n            int hi = num - 1;\n            \n            int len = query(root,lo,hi) + 1;\n            \n            update(root,num,len);\n            res = Math.max(res,len);\n        }                \n        return res;\n    }\n    \n    Node construct(int ss,int se){\n        if(ss == se){\n            Node node = new Node();\n            node.start = ss;\n            node.end = se;\n            node.val = 0;\n            return node;\n        }\n        \n        int mid = (ss + se) / 2;\n        Node node = new Node();\n        node.start = ss;\n        node.end = se;\n        node.left = construct(ss,mid);\n        node.right = construct(mid+1,se);\n        node.val = Math.max(node.left.val,node.right.val);\n        \n        return node;\n    }\n    \n    void update(Node node,int idx,int val){\n        if(node.start == node.end){\n            node.val = val;\n            return;\n        }\n        \n        int mid = (node.start + node.end) / 2;\n        if(idx <= mid){\n            update(node.left,idx,val);\n        }else{\n            update(node.right,idx,val);\n        }\n        \n        node.val = Math.max(node.left.val,node.right.val);\n    }\n    \n    int query(Node node,int qs,int qe){\n        if(node.start > qe || node.end < qs){\n            return 0;\n        }else if(node.start >= qs && node.end <= qe){\n            return node.val;\n        }else{\n            int lval = query(node.left,qs,qe);\n            int rval = query(node.right,qs,qe);\n            return Math.max(lval,rval);\n        }\n    }\n}\n\n\n\n\n\n/*class Solution {\n    public int lengthOfLIS(int[] nums, int k) {\n        int n=nums.length;\n        int dp[]=new int[n];\n        Arrays.fill(dp,1);\n        int ans=1;\n        for(int i=1;i<n;i++)\n        {\n            for(int prev=0;prev<=i-1;prev++)\n            {\n                if(nums[i-1]<nums[i] && nums[i]-nums[prev]<=k && dp[i]<dp[prev]+1)\n                {\n                    dp[i]=dp[prev]+1;\n                }\n                ans=(int)Math.max(ans,dp[i]);\n            }\n        }\n        return ans;\n    }\n}*/","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-increasing-subsequence-ii","has_notes":false}