{"id":911354105,"lang":"java","lang_name":"Java","time":"2Â months","timestamp":1678264351,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/911354105/","is_pending":"Not Pending","title":"Validate Binary Tree Nodes","memory":"44 MB","code":"class Solution {\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\n        int[] parent = new int[n];\n        for(int i = 0; i < n; i++) {\n            parent[i] = i; //every node is parent of itselt\n        }\n        for(int i = 0; i < n; i++) {\n            int l = left[i];\n            int r = right[i];\n            int x = find(parent, i);\n            if(l != -1) {\n                int root = find(parent, l);\n                if(root == x) return false; // left node already has a parent\n                union(parent, i, l);\n            }\n            if(r != -1) {\n                int root = find(parent, r); \n                if(root == x) return false; // right node already has a parent\n                union(parent, i, r);\n            }\n        }\n        int root = find(parent, 0);\n        for(int i = 1; i < n; i++) {\n            int rootI = find(parent, i);\n            if(root != rootI) return false; //Root of all node should be same - note the path compression\n        }\n        return true;\n    }\n    \n    void union(int[] parent, int x, int y) {\n        parent[y] = x;\n    }\n    \n    int find(int[] parent, int x) {\n        if(parent[x] != x) {\n\t\t    //Path compression for faster parent search - this makes Tree root as parent of all nodes\n            parent[x] = find(parent, parent[x]); \n            return parent[x];\n        }\n        return x;\n    }\n    \n}","compare_result":"1111111111111111111111111111111111111111111","title_slug":"validate-binary-tree-nodes","has_notes":false}