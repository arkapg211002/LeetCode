{"id":833007201,"lang":"java","lang_name":"Java","time":"6 months, 1 week","timestamp":1667092469,"status":10,"status_display":"Accepted","runtime":"67 ms","url":"/submissions/detail/833007201/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"54.1 MB","code":"class Solution {\n    int[][] arr;//just a reference variable to get size of supplied array.\n    boolean inRange(int i,int j){//helps in finding out if the request is out of bound or not.\n        //arr used here\n        return i>=0&&i<arr.length && j>=0 && j<arr[0].length;\n    }\n    public int shortestPath(int[][] grid, int k) {\n        //stores the state of current branch's head. {i,j,k,cost}\n        int[] state=new int[]{0,0,k,0};\n        arr=grid;\n        int[] v={0,0,1,-1};//possible verticle movements\n        int[] h={1,-1,0,0};//\"\" horizontal \"\"\n        //visited array store the maximum bombs left yet in reaching this location. \n        int[][] visited=new int[grid.length][grid[0].length];\n        for(int[] arr:visited){\n            Arrays.fill(arr,Integer.MIN_VALUE);//populating with Integer.MIN_VALUE as there may be chances we never reach that location.\n        }\n        //queue to acheave our bfs\n        Queue<int[]> q=new LinkedList<>();\n        q.add(state);\n        while(!q.isEmpty()){\n            state=q.poll();\n            //extracting values from the state\n            int a=state[0],b=state[1],bomb=state[2],val=state[3];\n            if(a==grid.length-1&&b==grid[0].length-1) return val;\n            //this is a crucial arguments as prevent us from taking any bad decision.\n            if(visited[state[0]][state[1]]>=state[2]) continue;\n            //no state visited the location yet hence adding\n            visited[state[0]][state[1]]=state[2];\n            for(int i=0;i<4;i++){\n                //checking if the request is in range or not\n                if(inRange(a+v[i],b+h[i])){\n                    //if hit the wall with no bombs left stop the branch expension.\n                    if(grid[a+v[i]][b+h[i]]==1&&bomb<=0) continue;\n                    //if have bomb move aheading by spending one bomb\n                    if(grid[a+v[i]][b+h[i]]==1){\n                     q.add(new int[]{a+v[i],b+h[i],bomb-1,val+1});\n                    }\n                    else{\n                        //no need of bomb guys calm down\n                        q.add(new int[]{a+v[i],b+h[i],bomb,val+1});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false}