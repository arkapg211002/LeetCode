{"id":933959564,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1681537236,"status":10,"status_display":"Accepted","runtime":"218 ms","url":"/submissions/detail/933959564/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"112.7 MB","code":"class Solution {\n    // creating adjacency matrix\n    Map<Integer , List<Integer>> tree = new HashMap<>();\n\n    int[] parent = null;\n    int[] dist = null;\n\n    private void constructTree(int[][] edges){\n        int n = edges.length;\n\n        for(int i = 0; i < n; i++){ // checking every pair [ai , bi]\n\n            int n1 = edges[i][0]; // ith row 0th col\n            int n2 = edges[i][1]; // ith row 1st col\n\n            if(!tree.containsKey(n1)){ // if n1 is not present in map\n                tree.put(n1,new ArrayList<>()); // insert it into the map with a empty list\n            }\n            if(!tree.containsKey(n2)){ // same goes for n2 \n                tree.put(n2,new ArrayList<>());\n            }\n            tree.get(n1).add(n2); // it is showing that n1 is connected with n2\n            tree.get(n2).add(n1); // it is showing that n2 is connected with n1\n        }\n    }\n\n    private void dfsToFindParent(int curr , int currParent , int currDist){\n        dist[curr] = currDist;\n        parent[curr] = currParent;\n\n        for(Integer currNeighbour : tree.get(curr)){\n            if(currNeighbour == currParent){ // if its visited skip it\n                continue;\n            }\n            dfsToFindParent(currNeighbour , curr , currDist + 1); // call dfs for neighbours which are not visited yet\n        }\n\n    }\n\n    Set<Integer> visited = new HashSet<>();\n    int ans = 0;\n    int maxAns = Integer.MIN_VALUE;\n\n    private void dfs(int curr , int[] amount){\n\n        visited.add(curr); // add it into the visitedSet\n        ans = ans + amount[curr]; // calc currentProfit \n        int trav = 0; // TO detect the leaf node (already the neighbour nodes for leaf node are visited)\n        for(Integer currNeighbour : tree.get(curr)){ // if neighbour is already visited skip it (check it in set)\n            if(visited.contains(currNeighbour)){\n                continue; \n            }\n            trav++;\n            dfs(currNeighbour,amount); // calling dfs for neighbours\n        }\n        if(trav == 0){ // reach the leaf node\n        maxAns = Math.max(ans , maxAns); // calculate maxProfit\n        }\n        ans = ans - amount[curr]; // backtracking so that we can track other paths also \n    }\n\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n\n        constructTree(edges); // construct a adjacency matrix\n        int n = edges.length;\n        parent = new int[n + 1];\n        dist = new int[n + 1];\n\n        Arrays.fill(parent,-1);\n        Arrays.fill(dist,-1);\n\n        dfsToFindParent(0,0,0); // (curr , currParent , currdist)\n\n        int curr = bob;   // from bob to when curr reach 0\n        int currDist = 0;\n\n        //update the parent and amount at each node \n        while(curr != 0){\n            if(dist[curr] > currDist){ // if dist of currNode from root node is greater than currDist from bob's node\n            // that means bob reaches first so alice is not concerned about this one at that particular time so amt[curr] = 0;\n                amount[curr] = 0; \n            }\n            else if(dist[curr] == currDist){ // if both reach at same node simulataneously than divide the amount by 2 \n                amount[curr] /= 2;\n            }\n            curr = parent[curr]; // update curr with parent of curr\n            currDist++; // inc curDist\n        }\n        //Now find the max sum you can obtain when you start moving from root node to any one of the leaf node (dfs)\n        dfs(0,amount);\n\n        return maxAns; // return the maximum profit \n    }\n}","compare_result":"1111111111111111111111111111111","title_slug":"most-profitable-path-in-a-tree","has_notes":false}