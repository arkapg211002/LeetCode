{"id":941152677,"lang":"java","lang_name":"Java","time":"1 week, 2 days","timestamp":1682695632,"status":10,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/941152677/","is_pending":"Not Pending","title":"Count Subtrees With Max Distance Between Cities","memory":"43.1 MB","code":"class Solution {\n    List<Integer>[] tree, subTree;\n    int subTreeRoot, maxPath;\n    boolean[] inStack;\n    int[] ans;\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) \n    {\n        buildTree(n, edges);\n        ans = new int[n - 1];\n        solve(0);\n        return ans;\n    }\n    public void buildTree(int n, int[][] edges) \n    {\n        tree = new List[n];\n        subTree = new List[n];\n        inStack = new boolean[n];\n        for (int i = 0; i < n; ++i) \n        {\n            tree[i] = new ArrayList<>();\n            subTree[i] = new ArrayList<>();\n        }\n        for (int[] e : edges) \n        {\n            tree[e[0] - 1].add(e[1] - 1);\n            tree[e[1] - 1].add(e[0] - 1);\n        }\n    }\n    public void solve(int i) \n    {\n        subTreeRoot = i;\n        inStack[i] = true;\n        buildSubTree(0, 0, Collections.singletonList(i), new ArrayList<>());\n        for (int e : tree[i]) \n        {\n            if (inStack[e]) continue;\n            solve(e);\n        }\n    }\n    public void buildSubTree(int i, int j, List<Integer> fronteer, List<Integer> next) \n    {\n        if (i >= fronteer.size()) \n        {\n            buildNextLevel(next);\n            return;\n        }\n        int curr = fronteer.get(i);\n        if (j >= tree[curr].size()) \n            buildSubTree(i + 1, 0, fronteer, next);\n        else \n        {\n            int succ = tree[curr].get(j);\n            if (inStack[succ]) \n            {\n                buildSubTree(i, j + 1, fronteer, next);\n                return;\n            }\n            inStack[succ] = true;\n            next.add(succ);\n            subTree[curr].add(succ);\n            buildSubTree(i, j + 1, fronteer, next);\n            next.remove(next.size() - 1);\n            subTree[curr].remove(subTree[curr].size() - 1);\n            buildSubTree(i, j + 1, fronteer, next);\n            inStack[succ] = false;\n        }\n    }\n    public void buildNextLevel(List<Integer> next) \n    {\n        if (next.isEmpty()) \n        { \n            maxPath = 0;\n            computeMaxPath(subTreeRoot);\n            if (maxPath > 1) \n                ++ans[maxPath - 2];\n            \n        } \n        else \n            buildSubTree(0, 0, next, new ArrayList<>());\n        \n    }\n    public int computeMaxPath(int i) \n    {\n        int max = 0, prevMax = 0;\n        for (int child : subTree[i]) \n        {\n            int h = computeMaxPath(child);\n            if (h >= max) \n            {\n                prevMax = max;\n                max = h;\n            } \n            else \n                prevMax = Integer.max(prevMax, h);\n            \n        }\n        maxPath = Integer.max(maxPath, prevMax + max + 1);\n        return max + 1;\n    }\n}","compare_result":"1111111111111111111111111111111","title_slug":"count-subtrees-with-max-distance-between-cities","has_notes":false}