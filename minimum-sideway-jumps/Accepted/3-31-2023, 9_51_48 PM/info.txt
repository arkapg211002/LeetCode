{"id":925454618,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1680279708,"status":10,"status_display":"Accepted","runtime":"34 ms","url":"/submissions/detail/925454618/","is_pending":"Not Pending","title":"Minimum Sideway Jumps","memory":"132.5 MB","code":"class Solution {\n    public int minSideJumps(int[] obstacles) {\n        // int[][] dp = new int[4][obstacles.length+1];   //Not needed for space opt\n\n        //Memoization \n        // for(int arr[]: dp){\n        //     Arrays.fill(arr,Integer.MAX_VALUE);\n        // }\n        // return solveMem(obstacles, 2, 0, dp);\n\n        //Tabulation\n        // return solveTab(obstacles, dp);\n\n        //Space Opt (we just need two arrays actually one to store the dat we working on RN. and the other to store the prev data)\n        return solveSpaceOpt(obstacles);\n    }\n\n\n    private int solveSpaceOpt(int[] obstacles){\n        int[] curr = new int[4], prev = new int[4];\n\n        for(int i = obstacles.length-2 ; i>=0 ; i--){\n            for(int path = 3 ; path>=1 ; path--){\n                int minSS = Integer.MAX_VALUE;\n\n                if(obstacles[i+1]!=path){\n                    minSS = prev[path];\n                }\n\n                else{\n                    if(path-2==1 && obstacles[i]!=path-2){\n                        minSS = 1 + prev[path-2];\n                    }\n                    if(path+2==3 && obstacles[i]!=path+2){\n                        minSS = Math.min(minSS, 1 + prev[path+2]);\n                    }\n                    if(path-1>=1 && obstacles[i]!=path-1){\n                        minSS = Math.min(minSS, 1 + prev[path-1]);\n                    }\n                    if(path+1<=3 && obstacles[i]!=path+1){\n                        minSS = Math.min(minSS, 1 + prev[path+1]);\n                    }\n                }\n                curr[path]=minSS;\n            }\n            //copyint the curr row to the prev row\n            for(int j=0 ; j<curr.length ; j++){\n                prev[j]=curr[j];\n            }\n        }\n        return curr[2];\n    }\n\n\n    private int solveTab(int[] obstacles, int[][] dp){\n        for(int i = obstacles.length-2 ; i>=0 ; i--){\n            for(int path = 3 ; path>=1 ; path--){\n                int minSS = Integer.MAX_VALUE;\n\n                if(obstacles[i+1]!=path){\n                    minSS = dp[path][i+1];\n                }\n\n                //in Memoization we haven't done +1 to 'i' for else case\n                //but here we need to do +1  as we will need to check for the next col in dp\n\n                else{\n                    if(path-2==1 && obstacles[i]!=path-2){\n                        minSS = 1 + dp[path-2][i+1];\n                    }\n                    if(path+2==3 && obstacles[i]!=path+2){\n                        minSS = Math.min(minSS, 1 + dp[path+2][i+1]);\n                    }\n                    if(path-1>=1 && obstacles[i]!=path-1){\n                        minSS = Math.min(minSS, 1 + dp[path-1][i+1]);\n                    }\n                    if(path+1<=3 && obstacles[i]!=path+1){\n                        minSS = Math.min(minSS, 1 + dp[path+1][i+1]);\n                    }\n                }\n                dp[path][i]=minSS;\n            }\n        }\n        return dp[2][0];\n    }\n\n\n    private int solveMem(int[] obstacles, int path, int i, int[][] dp){\n        if(i==obstacles.length-1){\n            return 0;\n        }\n\n        if(dp[path][i]!=Integer.MAX_VALUE){\n            return dp[path][i];\n        }\n\n        int minSS = Integer.MAX_VALUE;\n\n        //if there is no obstacle in path we move frwd\n        if(obstacles[i+1]!=path){\n            minSS = solveMem(obstacles, path, i+1, dp);\n        }\n        else{\n            //for the 3rd path only(jumping 2 paths up)\n            if(path-2==1 && obstacles[i]!=path-2){\n                minSS = 1 + solveMem(obstacles, path-2, i, dp);\n            }\n\n            //for the 1st part only(jumping 2 paths down)\n            if(path+2==3 && obstacles[i]!=path+2){\n                minSS = Math.min(minSS, 1 + solveMem(obstacles, path+2, i, dp));\n            }\n\n            //for all paths\n            if(path-1>=1 && obstacles[i]!=path-1){\n                minSS = Math.min(minSS, 1 + solveMem(obstacles, path-1, i, dp));\n            }\n            if(path+1<=3 && obstacles[i]!=path+1){\n                minSS = Math.min(minSS, 1 + solveMem(obstacles, path+1, i, dp));\n            }\n        }\n        return dp[path][i] = minSS;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111","title_slug":"minimum-sideway-jumps","has_notes":false}