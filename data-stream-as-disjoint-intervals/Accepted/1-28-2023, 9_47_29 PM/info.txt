{"id":886920468,"lang":"java","lang_name":"Java","time":"3 months, 1 week","timestamp":1674922649,"status":10,"status_display":"Accepted","runtime":"277 ms","url":"/submissions/detail/886920468/","is_pending":"Not Pending","title":"Data Stream as Disjoint Intervals","memory":"74.8 MB","code":"class SummaryRanges {\n    // We will use a treeset data structure \n    // it will keep our numbers in sorted order\n    private TreeSet<Integer> set;\n    public SummaryRanges() {\n        set = new TreeSet<>();  // initialise the treeset\n    }\n    \n    public void addNum(int value) {\n        set.add(value); // add the value to treeset\n    }\n    \n    public int[][] getIntervals() {\n        if (set.isEmpty()) {        // if set is empty\n            return new int[0][];    // return empty array\n        }\n\n        // initialise an arraylist to store the intervals\n        List<int[]> intervals = new ArrayList<>();\n        // initialise the start and end values with the \n        // first element that is present in the set\n        int start = set.first();\n        int end = set.first();\n\n        // we will iterate on the set, if its at number adjacent to 'end'\n        // we will update 'end' until we encounter a disjoint number\n        for (int v : set) {\n            // simply skip the first element because\n            // we ned to check from second element\n            if (v == start) {   \n                continue;       \n            } \n            // if the number is +1 the 'end' (adjacent), we will update 'end'\n            // say 'end' is 6, we encounter 7, so 6 & 7 are consecutive/adjacent\n            // so 'end' is updated to 7\n            else if (v == end + 1) {\n                end = v;\n            } \n            // when we find a disjoint case, say 'end' is 7 and we encounter 9\n            // they are disjoint, so we push the interval obtained so far\n            else {\n                intervals.add(new int[] {start, end});  // pushing the interval\n                start = end = v;    // we will start afresh from 9\n            }\n        }\n\n        // at the end we will be left with an interval,\n        // because we finished iterating on the treeset\n        // so we will push that interval to the list\n        intervals.add(new int[] {start, end});\n        // return the list as a 2D array of intervals\n        return intervals.toArray(new int[0][]);\n    }\n}","compare_result":"111111111","title_slug":"data-stream-as-disjoint-intervals","has_notes":false}