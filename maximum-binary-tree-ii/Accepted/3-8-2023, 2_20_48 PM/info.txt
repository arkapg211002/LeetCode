{"id":911361359,"lang":"java","lang_name":"Java","time":"2Â months","timestamp":1678265448,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/911361359/","is_pending":"Not Pending","title":"Maximum Binary Tree II","memory":"41.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode insertIntoMaxTree(TreeNode root, int val) {\n        TreeNode temp = root;\n        TreeNode tempParent = null;\n        /**\n        * Find node in the right subtree which is more than incoming val\n        */\n        while (temp != null && val < temp.val) {\n            tempParent = temp;\n            temp = temp.right;\n        }\n\n        TreeNode newNode = new TreeNode(val);\n        // case 1: val > root.val\n        if (tempParent == null) {\n            tempParent = newNode;\n            tempParent.left = root;\n            return tempParent;\n        }\n\n        if (temp == null) {\n            //val is smallest in right subtree\n            tempParent.right = newNode;\n        } else {\n            //val is more than some node in right subtree and les than   some nodes\n            tempParent.right = newNode;\n            newNode.left = temp;\n        }\n        return root;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-binary-tree-ii","has_notes":false}