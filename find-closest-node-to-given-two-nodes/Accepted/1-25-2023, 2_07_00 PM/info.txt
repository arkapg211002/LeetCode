{"id":884901447,"lang":"java","lang_name":"Java","time":"3 months, 1 week","timestamp":1674635820,"status":10,"status_display":"Accepted","runtime":"263 ms","url":"/submissions/detail/884901447/","is_pending":"Not Pending","title":"Find Closest Node to Given Two Nodes","memory":"149.3 MB","code":"class Solution {\n    // Function for Depth First Search\n    void dfs(int i, boolean[] visited, ArrayList<ArrayList<Integer>> adj, int[] distance_node1, int dist)\n    {\n        // Marking the node visited\n        visited[i]=true;\n        // Storing the distance \n        distance_node1[i]=dist;\n        // Checking the further nodes\n        for (int it: adj.get(i)) if (!visited[it]) dfs(it, visited, adj, distance_node1, dist+1);\n    }\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\n        // Data structure to store Distance of nodes from node1 & node 2\n        int[] distance_node1 = new int[edges.length];\n        int[] distance_node2 = new int[edges.length];\n        Arrays.fill(distance_node1, Integer.MAX_VALUE);\n        Arrays.fill(distance_node2, Integer.MAX_VALUE);\n        // Visited array to keep a traack of visited nodes\n        boolean[] visited = new boolean[edges.length];\n        // Declaring Adjacency List\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\n        for (int i=0;i<edges.length;i++)\n        {\n            adj.add(new ArrayList<Integer>());\n        }\n\n        // Filling Adjacency List\n        for (int i=0;i<edges.length;i++)\n        {\n            // Treating -1 as self loop\n            if (edges[i]==-1) adj.get(i).add(i);\n            else adj.get(i).add(edges[i]);\n        }\n        // Calling dfs to fill the distance needed for each node\n        dfs(node1, visited, adj, distance_node1, 0);\n        // Reset the visited array after first dfs call\n        Arrays.fill(visited, false);\n        // Calling dfs to fill the distance needed for each node\n        dfs(node2, visited, adj, distance_node2, 0);\n\n        int ans=Integer.MAX_VALUE;\n        // Keeping track of index\n        int ind=-1;\n        for (int i=0;i<edges.length;i++)\n        {\n            // Minimising the maximum distance of node from node1 & node2\n            if (ans>Math.max(distance_node1[i],distance_node2[i]))\n            {\n                ans=Math.max(distance_node1[i],distance_node2[i]);\n                ind=i;\n            }\n        }\n        // Return the index\n        return ind;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-closest-node-to-given-two-nodes","has_notes":false}