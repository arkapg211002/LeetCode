{"id":911358014,"lang":"java","lang_name":"Java","time":"2Â months","timestamp":1678264939,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/911358014/","is_pending":"Not Pending","title":"Flip Equivalent Binary Trees","memory":"40.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        if(root1 == null || root2 == null){\n            return root1 == root2;\n        }\n        if(root1.val != root2.val){\n            return false;\n        }\n        ArrayDeque<TreeNode> q1 = new ArrayDeque<>();\n        ArrayDeque<TreeNode> q2 = new ArrayDeque<>();\n        q1.offer(root1);\n        q2.offer(root2);\n        int lvl = 1;\n        while(!q1.isEmpty() && !q2.isEmpty()){\n            if(q1.size() != q2.size()){\n                return false;\n            }\n            int size = q1.size();\n           \n            for(int i = 0; i < size; i++){\n                TreeNode n1 = q1.poll();\n                TreeNode n2 = q2.poll();\n                TreeNode l1 = n1.left == null ? new TreeNode(-1) : n1.left;\n                TreeNode l2 = n2.left == null ? new TreeNode(-1) : n2.left;\n                TreeNode r1 = n1.right == null ? new TreeNode(-1) : n1.right;\n                TreeNode r2 = n2.right == null ? new TreeNode(-1) : n2.right;\n\n                if(l1.val == l2.val && r2.val == r1.val){\n                    if(l1.val != -1){\n                        q1.offer(l1);\n                    }\n                    if(r1.val != -1){\n                        q1.offer(r1);\n                    }\n                    if(l2.val != -1){\n                        q2.offer(l2);\n                    }\n                    if(r2.val != -1){\n                        q2.offer(r2);\n                    }\n                }else if(l1.val == r2.val && r1.val == l2.val){\n                    if(l1.val != -1){\n                        q1.offer(l1);\n                    }\n                    if(r1.val != -1){\n                        q1.offer(r1);\n                    }\n                    if(r2.val != -1){\n                        q2.offer(r2);\n                    }\n                    if(l2.val != -1){\n                        q2.offer(l2);\n                    }\n                }else{\n                    return false;\n                }\n            }\n            \n            lvl++;\n        }\n        return q1.isEmpty() && q2.isEmpty();\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flip-equivalent-binary-trees","has_notes":false}